Design a Locker management system for an ecommerce store. While performing a purchase, the users can opt for their packages to get delivered at a Locker system close to their place. The delivery person will place the package in a locker. An otp will be generated and sent to the user once the package is added to the locker.

As per the userâ€™s convenience, they can visit the locker, enter the otp and get their parcel. Further, if the users want to return the goods, they can visit the locker and place the item. Delivery guy will get an otp which can be used to unlock the locker.

Following are the expectations from the system:
Person asks the system to allocate a locker for a given package. Assume random allocation for now. The system should be extensible and accommodate allocation of locker based on the size of the input package
The system must generate a code/otp and send it to the user along with the locker details
The user can enter the otp & locker details to unlock the locker
Once the package is taken out, the locker can be allocated for any other order
Users can use the locker for returning an item. OTP/code will be sent to the delivery person in this case
Operations/Admin can view & vacate all lockers which are in use for more than 3 days






enitty classes:
  - Locker
  - Package
  - User
  - Otp

services required:

golden rule: while designing each service, you have to argue wehther you need singleton for that or not.
             sometimes logic can be placed inside a class and we can make this class singelton, but it can
             be over engineering. ex: in database connection, you know every API request creates connection with database
             so everytime API request will create new objects , hence we make it singleton.
             

  LockerService
      Locker allocateLocker(Package pkg)
      void vacateLocker(String lockerId)
      List<Locker> getOverdueLockers(Duration timeLimit)

  OtpService
      String generateOtp(String lockerId, DeliveryType type)
      boolean validateOtp(String lockerId, String otp, DeliveryType type)

  NotificationService
    void sendOtp(String phoneNumber, String otp, Locker lockerDetails)

  AccessService
    boolean unlockLocker(String lockerId, String otp, DeliveryType type)

  AdminService
    List<Locker> getOverdueLockers()
    void forceVacate(String lockerId)



Design Pattern we can use:
  Strategy Pattern	: locker allocation strategies (e.g., random, size-based,location based:though in this question location is not a requirement so skip it)
  Factory Pattern	To generate the right strategy (e.g., based on rules or configs:some criteria will be there to decide if we want to do size based allocation, AC/Non-AC based on prime member)
  Singleton Pattern	For services like LockerService, OtpService, etc.(creating otp is a shared state , so everyone would use this service without creating multiple objects)
  Observer Pattern (Conceptual)	Notify user/delivery agent when OTP is generated(user and delivery partner and admin are three different entities which needs to be notified when package is dropped)
  Facade Pattern	AccessService hides the complexity of unlocking (OTP + locker checks): user should not concern about how unlocking is happening and otp is generating, he would imply enter the otp and boom.


// Enums
public enum LockerSize {
    SMALL, MEDIUM, LARGE;
}

public enum PackageSize {
    SMALL, MEDIUM, LARGE;
}

public enum DeliveryType {
    DELIVERY, RETURN;
}

public enum OtpType {
    DELIVERY, RETURN;
}

// Entity: User
public class User {
    private String userId;
    private String name;
    private String phoneNumber;

    public User(String userId, String name, String phoneNumber) {
        this.userId = userId;
        this.name = name;
        this.phoneNumber = phoneNumber;
    }

    public String getUserId() {
        return userId;
    }

    public String getName() {
        return name;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }
}

// Entity: Package
public class Package {
    private String packageId;
    private String userId;
    private PackageSize size;
    private DeliveryType deliveryType;
    private LocalDateTime createdAt;

    public Package(String packageId, String userId, PackageSize size, DeliveryType deliveryType) {
        this.packageId = packageId;
        this.userId = userId;
        this.size = size;
        this.deliveryType = deliveryType;
        this.createdAt = LocalDateTime.now();
    }

    public String getPackageId() {
        return packageId;
    }

    public String getUserId() {
        return userId;
    }

    public PackageSize getSize() {
        return size;
    }

    public DeliveryType getDeliveryType() {
        return deliveryType;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
}

// Entity: Locker
public class Locker {
    private String lockerId;
    private LockerSize size;
    private boolean isOccupied;
    private Package storedPackage;
    private LocalDateTime lastAccessTime;

    public Locker(String lockerId, LockerSize size) {
        this.lockerId = lockerId;
        this.size = size;
        this.isOccupied = false;
    }

    public String getLockerId() {
        return lockerId;
    }

    public LockerSize getSize() {
        return size;
    }

    public boolean isOccupied() {
        return isOccupied;
    }

    public Package getStoredPackage() {
        return storedPackage;
    }

    public LocalDateTime getOccupiedAt() {
        return lastAccessTime;
    }

    public void storePackage(Package pkg) {
        this.storedPackage = pkg;
        this.isOccupied = true;
        this.lastAccessTime = LocalDateTime.now();
    }

    public void vacate() {
        this.storedPackage = null;
        this.isOccupied = false;
        this.lastAccessTime = LocalDateTime.now();
    }
}

// Entity: Otp
public class Otp {
    private final String value;

    public Otp(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    @Override
    public String toString() {
        return "Otp{" + "value='" + value + '\'' + '}';
    }
}

// OtpService Singleton
public class OtpService {
    private static OtpService instance = null;
    private Map<String, String> otpMap = new HashMap<>();
    private Random random = new Random();

    private OtpService() {}

    public static OtpService getInstance() {
        if (instance == null) {
            instance = new OtpService();
        }
        return instance;
    }

    public String generateOtp(String lockerId) {
        String otp = String.format("%06d", random.nextInt(1000000));
        otpMap.put(lockerId, otp);
        return otp;
    }

    public boolean validateOtp(String lockerId, String enteredOtp) {
        String expectedOtp = otpMap.get(lockerId);
        if (expectedOtp != null && expectedOtp.equals(enteredOtp)) {
            otpMap.remove(lockerId);
            return true;
        }
        return false;
    }
}

// Strategy Interface
public interface LockerAllocationStrategy {
    Locker allocate(List<Locker> lockers, Package pkg);
}

// Random Strategy
public class RandomLockerAllocationStrategy implements LockerAllocationStrategy {
    public Locker allocate(List<Locker> lockers, Package pkg) {
        for (Locker locker : lockers) {
            if (!locker.isOccupied()) {
                locker.storePackage(pkg);
                return locker;
            }
        }
        return null;
    }
}

// Size-Based Strategy
public class SizeBasedLockerAllocationStrategy implements LockerAllocationStrategy {
    public Locker allocate(List<Locker> lockers, Package pkg) {
        for (Locker locker : lockers) {
            if (!locker.isOccupied() && locker.getSize().name().equals(pkg.getSize().name())) {
                locker.storePackage(pkg);
                return locker;
            }
        }
        return null;
    }
}

// LockerService Singleton
public class LockerService {
    private static LockerService instance = null;
    private List<Locker> lockers = new ArrayList<>();
    private LockerAllocationStrategy allocationStrategy;

    private LockerService() {}

    public static LockerService getInstance() {
        if (instance == null) {
            instance = new LockerService();
        }
        return instance;
    }

    public void setAllocationStrategy(LockerAllocationStrategy strategy) {
        this.allocationStrategy = strategy;
    }

    public void addLocker(Locker locker) {
        lockers.add(locker);
    }

    public Locker allocateLocker(Package pkg) {
        if (allocationStrategy == null) {
            throw new IllegalStateException("No allocation strategy configured");
        }
        return allocationStrategy.allocate(lockers, pkg);
    }

    public List<Locker> getLockers() {
        return lockers;
    }
}

// AdminService Singleton
public class AdminService {
    private static AdminService instance = null;
    private List<Locker> lockers;

    private AdminService(List<Locker> lockers) {
        this.lockers = lockers;
    }

    public static AdminService getInstance(List<Locker> lockers) {
        if (instance == null) {
            instance = new AdminService(lockers);
        }
        return instance;
    }

    public List<Locker> getStaleOccupiedLockers() {
        List<Locker> staleLockers = new ArrayList<>();
        LocalDateTime now = LocalDateTime.now();
        for (Locker locker : lockers) {
            if (locker.isOccupied()) {
                Duration duration = Duration.between(locker.getOccupiedAt(), now);
                if (duration.toDays() > 3) {
                    staleLockers.add(locker);
                }
            }
        }
        return staleLockers;
    }

    public void forceVacateStaleLockers() {
        List<Locker> staleLockers = getStaleOccupiedLockers();
        for (Locker locker : staleLockers) {
            locker.vacate();
            System.out.println("Admin forcibly vacated locker: " + locker.getLockerId());
        }
    }
}

// Driver Code
public class Main {
    public static void main(String[] args) {
        // Create lockers
        Locker locker1 = new Locker("L1", LockerSize.SMALL);
        Locker locker2 = new Locker("L2", LockerSize.MEDIUM);

        // Initialize LockerService and set strategy
        LockerService lockerService = LockerService.getInstance();
        lockerService.addLocker(locker1);
        lockerService.addLocker(locker2);
        lockerService.setAllocationStrategy(new RandomLockerAllocationStrategy());

        // Create a package
        Package pkg = new Package("P1", "U1", PackageSize.SMALL, DeliveryType.DELIVERY);

        // Allocate locker
        Locker allocated = lockerService.allocateLocker(pkg);
        if (allocated != null) {
            System.out.println("Package stored in locker: " + allocated.getLockerId());
        } else {
            System.out.println("No locker available");
        }

        // Generate and validate OTP
        OtpService otpService = OtpService.getInstance();
        String otp = otpService.generateOtp(allocated.getLockerId());
        System.out.println("Generated OTP: " + otp);

        boolean isValid = otpService.validateOtp(allocated.getLockerId(), otp);
        System.out.println("OTP Valid: " + isValid);

        // Admin service demo
        AdminService adminService = AdminService.getInstance(lockerService.getLockers());
        adminService.forceVacateStaleLockers();
    }
}

























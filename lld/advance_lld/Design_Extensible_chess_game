laymen design:

class GameBoard(){
    hashMap<string, Piece> pos;
    
    GameBoard(){
      reset();  
    }
    
    reset(){
        // set this.pos
        // run for loop and create new Pieces for initial position
        // A1 = new Piece(rook, white)
        for(char x='A'; x < H; A++){
            for(int j=0; j < 8; j++){
              if(pos == "A1") new Hanthi(white,hanthi)
               continue;
              else if(pos == "A2") new Ghoda(white, ghoda)
            }
        }
    }
    
    move(string initialPosition,string finalPosition,string color){
        //apply checks whether piece at initialPosition has valid
        //move for final Position(if move is for raja, check he will not go in
        //danger)
        //if possible, update positions 
        //delet entry from pos for initialPosition and add an entry
        //with final Position with the same piece that was at initialPosition
        checkStaleMate();
        checkCheckMate();
        
        
    }
    
    checkStaleMate(){
        //findOppositeKaraja();
        //logic to check if raja is in danger
        //for all pieces of opposite colour , check if they can tackle raja
        //if yes,then check for checkMate()
           if(checkMate())
             return "checkMate"
            
        //else return "staleMate"
        
    }
    
    checkCheckMate(){
        //findWhiteKaraja();
        //logic to check if white ka raja is check
    }
}

interface Pieces {
    string type;
    string colour;
    
    
}

hanthi,ghoda etc claases will implement this interface

class Main {
    
    
    
    GameBoard board = new GameBoard();
    string color = "white";
    S.O.P("player 1 turn");
    board.move("H8", "G8",color)
    
}


problems:
1.GameBoard class has multiple problems:

Single Responsibility: Each class focuses on one job, improving clarity and maintainability.(move function is double respo)

- Avoid Duplication: Shared logic can be reused across multiple game modes or variants via service class.
  - suppose tomorrow we want customGameBoard that has 16*16 size and some extra piece of existing type.
  - move function will be same but we will have to define it again in customeGameBoardClass.
  - code reusability

- Open/Closed Principle: You can add new behavior without modifying existing classes.
  - even if u seperate the move function out  to seperate service class, suppose for customGameBoard class,
  - move logic changes. you will have to create another move function in service class(violation of open close principle)
  - multiple ways to do a task, so use strategie pattern for service class.
  - these kind of counter questions will come, though you are not expected to deter from your implementation
  - you will just have to tell them we can use this thing here.
    
    interface MoveStrategy {
      boolean move(GameBoard board, String from, String to, String color);
    }

    class StandardMoveService implements MoveStrategy {
        public boolean move(GameBoard board, String from, String to, String color) {
            // classic chess move logic
        }
    }
    
    class Chess960MoveService implements MoveStrategy {
          public boolean move(GameBoard board, String from, String to, String color) {
              // different logic due to shuffled back rank
          }
      }
  
      class GameBoard {
      private MoveStrategy moveStrategy;
  
      public GameBoard(MoveStrategy moveStrategy) {
          this.moveStrategy = moveStrategy;
      }
  
      public void move(String from, String to, String color) {
          moveStrategy.move(this, from, to, color);
      }
  }


 - movement is related to piece, each piece moves in a different way:
   Right now, Piece is just a bag of data (type, color). It doesn't encapsulate behavior.

    If you ever want different move logic for each piece type (Rook, Knight, Queen), you'll have to do:
    
    
    if (piece.type == "Rook") { // move logic }
    This breaks OCP and LSP.
    
    âœ… Fix: Make Piece an abstract class or interface, and create subclasses:
    
    
    abstract class Piece {
        String color;
        abstract boolean isValidMove(String from, String to, GameBoard board);
    }
    
    class Rook extends Piece { ... }
    class Knight extends Piece { ... }
    Now the board can call:
    
    
    piece.isValidMove(from, to, board);





  prerequisit:
  1. abstract factory/factory
  2. stragetgy pattern.
  3.Facade





=================================================better Design ===================================================

thought process:

1. Strategy Pattern

For implementing different move rules for each type of chess piece.

MoveStrategy interface

Concrete classes like PawnMoveStrategy, KnightMoveStrategy, etc.

Each Piece has a MoveStrategy instance.

ðŸ§© Problem it solves:
Imagine if you had written all piece move logic inside one canMove() method using a big if-else like:

if (piece is PAWN) { ... }
else if (piece is KNIGHT) { ... }
else if (piece is BISHOP) { ... }
âž¡ This violates Open/Closed Principle (OCP):
Youâ€™ll have to modify this logic every time you add or fix a piece behavior.


2. Factory Pattern

 - If you had to create all pieces like this manually:


board.placePiece(6, 0, new Pawn(Color.WHITE));
board.placePiece(6, 1, new Pawn(Color.WHITE));
// ... and so on for all pieces
âž¡ Youâ€™d end up with copy-paste code thatâ€™s hard to maintain, error-prone, and not scalable.

 What Factory Pattern does:
Centralizes object creation logic.

You just say: â€œHey, I want a PAWN of color WHITEâ€ â€” and the factory gives it to you.

Makes it easy to refactor creation logic later (e.g., add logging, cache, different variants of a piece, etc.)

ðŸ›  Benefit:
Adheres to Single Responsibility (creation logic lives in one place)

Reduces duplication

Makes the Board class clean and focused on layout only


// ChessGame.java

// Enums
enum Color {
    WHITE, BLACK
}

white = 1, black = 0

if(color == Color.White){

}

enum PieceType {
    KING, QUEEN, ROOK, BISHOP, KNIGHT, PAWN
}

// Position Classes
class Move {
    int fromRow, fromCol;
    int toRow, toCol;

    public Move(int fromRow, int fromCol, int toRow, int toCol) {
        this.fromRow = fromRow;
        this.fromCol = fromCol;
        this.toRow = toRow;
        this.toCol = toCol;
    }

    
} 

class Square {
    int row, col;
    Piece piece;

    public Square(int row, int col) {
        this.row = row;
        this.col = col;
    }

    public boolean isOccupied() {
        return piece != null;
    }
}

// Strategy Pattern: Movement Strategy Interface
interface MoveStrategy {
    boolean isValidMove(Board board, Move move, Color color);
}

// Concrete Strategies (example: Pawn only, rest can be added similarly)
class PawnMoveStrategy implements MoveStrategy {
    @Override
    public boolean isValidMove(Board board, Move move, Color color) {
        int dir = (color == Color.WHITE) ? -1 : 1;
        int startRow = (color == Color.WHITE) ? 6 : 1;

        Square from = board.getSquare(move.fromRow, move.fromCol);
        Square to = board.getSquare(move.toRow, move.toCol);

        if (move.toCol == move.fromCol && !to.isOccupied()) {
            if (move.toRow == move.fromRow + dir) return true;
            if (move.toRow == move.fromRow + 2 * dir && move.fromRow == startRow) return true;
        }

        if (Math.abs(move.toCol - move.fromCol) == 1 && move.toRow == move.fromRow + dir && to.isOccupied()) {
            return to.piece.color != color;
        }

        return false;
    }
}

// Abstract Piece Class
//if we have not used abstract class for pieces, we would have duplicated canMove function for each piece type
//since the specific move logic is already handled via strategy, each and every line of canMove function would be same
abstract class Piece {
    Color color;
    MoveStrategy moveStrategy;
    PieceType type;

    public Piece(Color color, MoveStrategy strategy, PieceType type) {
        this.color = color;
        this.moveStrategy = strategy;
        this.type = type;
    }

    public boolean canMove(Board board, Move move) {
        return moveStrategy.isValidMove(board, move, color);
    }
}

// Concrete Piece: Pawn Example
class Pawn extends Piece {
    public Pawn(Color color) {
        super(color, new PawnMoveStrategy(), PieceType.PAWN);
    }
}

// Add Knight, Rook, etc. similarly by creating respective strategy classes

// Board Class
class Board {
    private final Square[][] squares = new Square[8][8];

    public Board() {
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                squares[i][j] = new Square(i, j);
            }
        }
    }

    public Square getSquare(int row, int col) {
        return squares[row][col];
    }

    public void placePiece(int row, int col, Piece piece) {
        squares[row][col].piece = piece;
    }
}

// Piece Factory
class PieceFactory {
    public static Piece createPiece(PieceType type, Color color) {
        switch (type) {
            case PAWN: return new Pawn(color);
            // Add cases for other piece types
            default: throw new IllegalArgumentException("Unsupported piece type");
        }
    }
}

// Player
class Player {
    String name;
    Color color;

    public Player(String name, Color color) {
        this.name = name;
        this.color = color;
    }
}

// MoveValidator Service
class MoveValidator {
    public boolean isValidMove(Board board, Move move, Color currentPlayerColor) {
        Square from = board.getSquare(move.fromRow, move.fromCol);
        //below line handles the case where user might submit a request with invalid from square
        if (!from.isOccupied() || from.piece.color != currentPlayerColor) return false; 

        return from.piece.canMove(board, move);
    }
}

// GameManager: Controls Game Flow
class GameManagerFacade {
    private Board board;
    private Player whitePlayer, blackPlayer, currentPlayer;
    private MoveValidator validator;

    public GameManager(Player white, Player black) {
        this.whitePlayer = white;
        this.blackPlayer = black;
        this.currentPlayer = white;
        this.validator = new MoveValidator();
        this.board = new Board();
        initializeBoard();
    }

    // Set up only pawns here for simplicity
    private void initializeBoard() {
        for (int col = 0; col < 8; col++) {
            board.placePiece(1, col, PieceFactory.createPiece(PieceType.PAWN, Color.BLACK));
            board.placePiece(6, col, PieceFactory.createPiece(PieceType.PAWN, Color.WHITE));
        }
    }

    public void startGame(Move move) {
        // Example manual moves; replace with UI input in production
        Move move1 = new Move(6, 0, 5, 0); // white pawn
        if (validator.isValidMove(board, move1, currentPlayer.color)) {
            makeMove(move1);
            switchTurns();
        }
    }

    private void makeMove(Move move) {
        Square from = board.getSquare(move.fromRow, move.fromCol);
        Square to = board.getSquare(move.toRow, move.toCol);

        to.piece = from.piece;
        from.piece = null;
    }

    private void switchTurns() {
        currentPlayer = (currentPlayer == whitePlayer) ? blackPlayer : whitePlayer;
    }
}

// Driver Code
public class ChessGame {
    public static void main(String[] args) {
        Player white = new Player("Alice", Color.WHITE);
        Player black = new Player("Bob", Color.BLACK);
        GameManager game = new GameManagerFacade(white, black);
        game.startGame();
        
        game.starGame(Move move)
        
    }
}


cases handled:
1.new type of board can be added without mofdigying the existing class code anywhere(open/close).
2.Facade class doesn't know about object inititation logic for various pieces.(single respnsibility principle)
3.multiple validator for different type of  chess board type can be added without modifying existig code(Open/closed)
4.validtor obkect and board object inside facade class will be injected via constrcuot(dependency injection principle).
5.Since we can replace any parent clas object with child clas object, Liskov substituion principle is alos followed
6. Interface segregation principle is also followed.


ratne ka tareeka:
dry run:start top/down.
2.start from driver/main class and walkthrough the code.
3.at any step, check if any of the 5 SOLID principle is breaking.
















  

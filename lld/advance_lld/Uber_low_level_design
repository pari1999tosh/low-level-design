Uber low level design: 

Passengers can request a ride by providing:
 - Pickup location
 - Destination location
 - Ride type (e.g., Regular or Premium)
Drivers can:
 - Go online or offline
 - View nearby ride requests
 - Accept or decline a request
The system should:
 - Match ride requests with the nearest available driver
 - Update ride status as: REQUESTED ‚Üí ASSIGNED ‚Üí ONGOING ‚Üí COMPLETED ‚Üí CANCELLED
 - Calculate fare based on distance and ride type (ignore time-based fare for now)


why's and why not's:
 1. cancelling ride, booking ride etc are commands but we still don't use command patttern because cancelling is undo of booking
    but booking is not redo of cancelling. undo/redo is not a focus area here because it is irreversible.

Prerequisistes:
 1. Singleton.
 2. Strategy.
 3. Factory.

General Steps for any low level design interview( Link in Description)

1. Identify entity classes and service functions.

Entity Classes (Nouns + 1-line use)
  Passenger ‚Äì Represents a user requesting a ride.
  Driver ‚Äì Represents a user who can accept and fulfill ride requests.
  Location ‚Äì Holds latitude/longitude for pickup or destination.
  RideRequest ‚Äì Stores passenger request details: pickup, destination, ride type, status.
  Ride ‚Äì Represents an ongoing or completed ride (links Passenger, Driver, and RideRequest).
  RideType (enum) ‚Äì Defines ride categories (REGULAR, PREMIUM) for fare calculation.
  DriverStatus (enum) ‚Äì Tracks driver availability (ONLINE, OFFLINE, BUSY).

Service Functions (Business Operations + 1-line use)
  Passenger actions
    requestRide(pickup, destination, rideType) ‚Äì Create a new ride request.
    cancelRide(rideId) ‚Äì Cancel a ride before it starts.
  
  Driver actions
    goOnline(driverId) ‚Äì Make driver available for matching.
    goOffline(driverId) ‚Äì Make driver unavailable for matching.
    acceptRide(rideRequestId) ‚Äì Assign the ride to the driver.
    declineRide(rideRequestId) ‚Äì Remove ride request from driver‚Äôs list.
  
  Core system operations
    matchRide(rideRequest) ‚Äì Find nearest available driver for the request.
    calculateFare(distance, rideType) ‚Äì Compute ride fare based on rules.
    updateDriverLocation(driverId, location) ‚Äì Keep driver‚Äôs position updated in system.
    updateRideStatus(rideId, status) ‚Äì Change ride‚Äôs lifecycle state.


2. Identify which patterns you can use:

   Services that are stateful across the whole system and should have only one instance:
    - DriverService ‚Äì maintains the list of active drivers, their locations, and statuses system-wide.
    - RideMatchingService ‚Äì central authority to assign rides to drivers.
    - PaymentService ‚Äì handles fare calculation and payments consistently.
    - RideService ‚Äì keeps track of rides and their statuses; central source of truth.

   Interview reasoning: These are all ‚Äúsystem managers‚Äù with global state. Having multiple instances would cause inconsistent data or duplicate processing.
                        Singleton ensures a single point of coordination.

  Strategy Pattern
    We use this where behavior can vary at runtime without changing the main service logic.
    FareCalculationStrategy ‚Äì calculate fare differently for different ride types (e.g., SedanFareStrategy, SUVFareStrategy).
    RideMatchingStrategy (optional extension) ‚Äì current requirement says ‚Äúnearest driver,‚Äù 
    but we can easily add ‚Äúhighest-rated driver‚Äù or ‚Äúcheapest driver‚Äù later without touching RideMatchingService.

  Factory Pattern
    Used when object creation depends on dynamic input and we want to avoid cluttering code with if-else or switch.
    FareCalculationStrategyFactory ‚Äì returns the correct fare strategy based on ride type (Sedan, SUV, etc.).
    RideFactory (optional) ‚Äì if tomorrow different ride subtypes are introduced with specific fields, this can encapsulate their creation.

üí° Interview reasoning:
    Factory centralizes object creation logic, so new ride types or fare rules can be added without changing service code. This follows Open/Closed Principle.



=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================


flow diagram of system:

               +-----------------------+
               |       RideRequest      |
               +-----------------------+
               | - pickupLocation       |
               | - dropLocation         |
               | - rideType             |
               +-----------------------+
                        |
                        v
    +-------------------------------------------+
    | RideMatchingService  (Singleton)          |
    +-------------------------------------------+
    | - driverService: DriverService            |
    | - matchingStrategy: RideMatchingStrategy? |
    +-------------------------------------------+
    | + matchDriver(rideRequest)                |
    +-------------------------------------------+
                        |
                        v
    +-------------------------+
    | DriverService (Singleton)|
    +-------------------------+
    | - activeDrivers[]       |
    +-------------------------+
    | + updateLocation()      |
    | + getNearestDriver()    |
    +-------------------------+
                        |
                        v
                +------------------+
                | Driver            |
                +------------------+
                | - id             |
                | - name           |
                | - vehicle        |
                +------------------+
                        

RideService (Singleton)  ‚Üí  Tracks rides and statuses:
REQUESTED ‚Üí ASSIGNED ‚Üí ONGOING ‚Üí COMPLETED ‚Üí CANCELLED

    +--------------------------------+
    | RideService  (Singleton)       |
    +--------------------------------+
    | - rides[]                      |
    +--------------------------------+
    | + createRide(request, driver)  |
    | + updateRideStatus(rideId, s)  |
    +--------------------------------+
                        |
                        v
    +-------------------------+
    | Ride                    |
    +-------------------------+
    | - id                    |
    | - driver: Driver        |
    | - rider: Rider          |
    | - fare                  |
    | - status                |
    +-------------------------+

Fare Calculation:

    +-----------------------------------+
    | FareCalculationStrategy (interface) |
    +-----------------------------------+
    | + calculateFare(ride)             |
    +-----------------------------------+
       ^                 ^
       |                 |
+----------------+  +----------------+
| SedanFare      |  | SUVFare        |
+----------------+  +----------------+

Factory:

    +----------------------------------------+
    | FareCalculationStrategyFactory         |
    +----------------------------------------+
    | + getStrategy(rideType) : FareCalculationStrategy |
    +----------------------------------------+

Payment Handling:

    +------------------------------+
    | PaymentService (Singleton)   |
    +------------------------------+
    | + processPayment(ride)       |
    +------------------------------+


=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================


code flow:

// RideSharingApp.java

import java.util.*;

// ---------------------- ENTITY CLASSES ----------------------

abstract class Vehicle {
    String vehicleId;
    String model;
    String plateNumber;

    public Vehicle(String vehicleId, String model, String plateNumber) {
        this.vehicleId = vehicleId;
        this.model = model;
        this.plateNumber = plateNumber;
    }
}

class Car extends Vehicle {
    public Car(String id, String model, String plate) {
        super(id, model, plate);
    }
}

class Bike extends Vehicle {
    public Bike(String id, String model, String plate) {
        super(id, model, plate);
    }
}

class Driver {
    String driverId;
    String name;
    Vehicle vehicle;

    public Driver(String driverId, String name, Vehicle vehicle) {
        this.driverId = driverId;
        this.name = name;
        this.vehicle = vehicle;
    }
}

class Rider {
    String riderId;
    String name;

    public Rider(String riderId, String name) {
        this.riderId = riderId;
        this.name = name;
    }
}

// ---------------------- STRATEGY PATTERN ----------------------

interface FareCalculationStrategy {
    double calculateFare(double distanceKm);
}

class StandardFareStrategy implements FareCalculationStrategy {
    public double calculateFare(double distanceKm) {
        return 10 + distanceKm * 8; // base + per km
    }
}

class PremiumFareStrategy implements FareCalculationStrategy {
    public double calculateFare(double distanceKm) {
        return 20 + distanceKm * 15;
    }
}

// ---------------------- FACTORY PATTERN ----------------------

abstract class Ride {
    Rider rider;
    Driver driver;
    double distanceKm;
    FareCalculationStrategy fareStrategy;

    public Ride(Rider rider, Driver driver, double distanceKm, FareCalculationStrategy fareStrategy) {
        this.rider = rider;
        this.driver = driver;
        this.distanceKm = distanceKm;
        this.fareStrategy = fareStrategy;
    }

    public void startRide() {
        System.out.println("Ride started with driver: " + driver.name);
    }

    public void endRide() {
        double fare = fareStrategy.calculateFare(distanceKm);
        System.out.println("Ride ended. Fare: ‚Çπ" + fare);
    }
}

class StandardRide extends Ride {
    public StandardRide(Rider rider, Driver driver, double distanceKm) {
        super(rider, driver, distanceKm, new StandardFareStrategy());
    }
}

class PremiumRide extends Ride {
    public PremiumRide(Rider rider, Driver driver, double distanceKm) {
        super(rider, driver, distanceKm, new PremiumFareStrategy());
    }
}

class RideFactory {
    public static Ride createRide(String type, Rider rider, Driver driver, double distanceKm) {
        switch (type.toLowerCase()) {
            case "standard": return new StandardRide(rider, driver, distanceKm);
            case "premium": return new PremiumRide(rider, driver, distanceKm);
            default: throw new IllegalArgumentException("Invalid ride type");
        }
    }
}

// ---------------------- SINGLETON MANAGERS ----------------------

class DriverManager {
    private static DriverManager instance;
    private List<Driver> drivers = new ArrayList<>();

    private DriverManager() {}

    public static DriverManager getInstance() {
        if (instance == null) instance = new DriverManager();
        return instance;
    }

    public void registerDriver(Driver driver) {
        drivers.add(driver);
    }

    public Driver findAvailableDriver() {
        // For simplicity, return the first one
        return drivers.isEmpty() ? null : drivers.get(0);
    }
}

class RideManager {
    private static RideManager instance;

    private RideManager() {}

    public static RideManager getInstance() {
        if (instance == null) instance = new RideManager();
        return instance;
    }

    public Ride bookRide(String rideType, Rider rider, double distanceKm) {
        Driver driver = DriverManager.getInstance().findAvailableDriver();
        if (driver == null) throw new RuntimeException("No drivers available");
        return RideFactory.createRide(rideType, rider, driver, distanceKm);
    }
}

// ---------------------- CLIENT ----------------------

public class RideSharingApp {
    public static void main(String[] args) {
        // Setup
        DriverManager driverManager = DriverManager.getInstance();
        driverManager.registerDriver(new Driver("D1", "Amit", new Car("V1", "Toyota", "UP32AB1234")));

        Rider rider = new Rider("R1", "Paritosh");

        // Booking
        RideManager rideManager = RideManager.getInstance();
        Ride ride = rideManager.bookRide("Premium", rider, 12.5);

        // Ride lifecycle
        ride.startRide();
        ride.endRide();
    }
}



